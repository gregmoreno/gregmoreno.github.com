<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Greg Moreno]]></title>
  <link href="http://gregmoreno.ca/atom.xml" rel="self"/>
  <link href="http://gregmoreno.ca/"/>
  <updated>2017-02-10T20:31:30-08:00</updated>
  <id>http://gregmoreno.ca/</id>
  <author>
    <name><![CDATA[Greg Moreno]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Joy Ride in Ruby's spaceship]]></title>
    <link href="http://gregmoreno.ca/joy-ride-in-rubys-spaceship/"/>
    <updated>2016-02-16T20:52:04-08:00</updated>
    <id>http://gregmoreno.ca/joy-ride-in-rubys-spaceship</id>
    <content type="html"><![CDATA[<p>Ruby&rsquo;s <code>&lt;=&gt;</code> operator is commonly referred to as the spaceship in the community. You may not have
played with it directly but I bet you have relied on it a lot of times. Because, every time you use
sort an array, you are tapping in to the spaceship operator.</p>

<p>Now, why would you care? Because sometimes we need to sort things which does not have a natural ordering
computers are accustomed to. Take for example sorting clothes that use S, M, and L to refer to their sizes.
And to add more fun, how about putting XS, XL, and XXL into the mix.</p>

<p>Let&rsquo;s start with a bare class and see what happens.</p>

<pre><code>require 'minitest/autorun'

class Size
  attr_reader :size

  def initialize(size)
    @size = size.to_s.upcase
  end

  def to_s
    @size
  end
end

describe Size do
  let(:sizes) { %w[L S M].map { |s| Size.new(s) } }
  it { sizes.sort.map(&amp;:to_s).must_equal %w[S M L] }

  let(:a) { Size.new('S') }
  let(:b) { Size.new('M') }

  it { (a &gt; b).must_equal false }
  it { (a &lt; b).must_equal true }
end

$&gt; ruby size.rb                                                                                                     [2.1.2]
Run options: --seed 37770

# Running:

EEE

Finished in 0.001207s, 2486.1356 runs/s, 0.0000 assertions/s.

  1) Error:
Size#test_0001_anonymous:
ArgumentError: comparison of Size with Size failed
    size.rb:24:in `sort'
    size.rb:24:in `block (2 levels) in &lt;main&gt;'


  2) Error:
Size#test_0002_anonymous:
NoMethodError: undefined method `&gt;' for #&lt;Size:0x007f8a7bae6c50 @size="S"&gt;
    size.rb:29:in `block (2 levels) in &lt;main&gt;'


  3) Error:
Size#test_0003_anonymous:
NoMethodError: undefined method `&lt;' for #&lt;Size:0x007f8a7bae6390 @size="S"&gt;
    size.rb:30:in `block (2 levels) in &lt;main&gt;'

3 runs, 0 assertions, 0 failures, 3 errors, 0 skips
</code></pre>

<p>Our test failed and that&rsquo;s good news, isn&rsquo;t it? The first failure is because the default
implementation of <code>&lt;=&gt;</code> doesn&rsquo;t do all the comparison required to make <code>sort</code> work. To make this
work, we need to implement a <code>&lt;=&gt;</code> that returns the following:</p>

<ul>
<li>nil if the comparison does not makes sense</li>
<li>-1 if left side is less than right side</li>
<li>1 if left side is greater than right side</li>
<li>0 if left and right are the same</li>
</ul>


<p>Let&rsquo;s update our code to use the spaceship.</p>

<pre><code>class Size
  attr_reader :size

  SIZES = %w[S M L].freeze

  def initialize(size)
    @size = size.to_s.upcase
  end

  def to_s
    @size
  end

  def &lt;=&gt;(other)
    position &lt;=&gt; other.position
  end

  protected

  def position
    SIZES.index(size)
  end
end
</code></pre>

<p>Some things to ponder in our implementation.</p>

<ul>
<li>In Ruby, operator calls are just method calls where the left side is the receiver and right side is
the argument. In other words, this is  <code>a &lt;=&gt; b</code> is the same as <code>a.&lt;=&gt;(b)</code></li>
<li>It is common practice to call the argument as <code>other</code> as you know the other object :)</li>
<li>We leverage an existing implementation of <code>&lt;=&gt;</code>. The method <code>#index</code> returns the position of an element
in the array, which is a <code>Fixnum</code>. The <code>Fixnum</code> class already knows how to compare numbers.</li>
<li>We use <code>protected</code> to hide an implementation detail but at the same time allow us to use it within instance
methods of objects of the same class.</li>
</ul>


<p>Now, how about the other test failures? Do we need to implement the <code>&lt;</code> and <code>&gt;</code> operators as well?
Fortunately, Ruby got our back. We just need to include the module <a href="http://ruby-doc.org/core-2.3.0/Comparable.html"><code>Comparable</code></a>
and we&rsquo;re good. But wait, there&rsquo;s more! By including the <code>Comparable</code> module, we also get
<code>&lt;=</code>, <code>&gt;=</code>, and <code>==</code> for free.</p>

<p>Here&rsquo;s the full implementation with additional test scenarios, including a reverse sort.</p>

<pre><code>require 'minitest/autorun'

class Size
  include Comparable

  SIZES = %w[S M L].freeze

  attr_reader :size

  def initialize(size)
    @size = size.to_s.upcase
  end

  def to_s
    @size
  end

  def &lt;=&gt;(other)
    position &lt;=&gt; other.position
  end

  protected

  def position
    SIZES.index(size)
  end
end

describe Size do
  let(:sizes) { %w[L S M].map { |s| Size.new(s) } }

  it { sizes.sort.map(&amp;:to_s).must_equal %w[S M L] }
  it { sizes.sort { |a,b| b &lt;=&gt; a }.map(&amp;:to_s).must_equal %w[L M S] }

  let(:a) { Size.new('S') }
  let(:b) { Size.new('M') }

  it { (a &gt; b).must_equal false }
  it { (a &lt; b).must_equal true }
  it { (a &gt;= b).must_equal false }
  it { (a &lt;= b).must_equal true }
  it { (a == b).must_equal false }
end

$&gt; ruby size.rb                                                                                                     [2.1.2]
Run options: --seed 44807

# Running:

.......

Finished in 0.001490s, 4698.8003 runs/s, 4698.8003 assertions/s.

7 runs, 7 assertions, 0 failures, 0 errors, 0 skips
</code></pre>

<p><em>Exercise:</em>  Software versions often follow the convention <code>major.minor.patch</code>. Create a <code>Version</code> class
that takes a string version, e.g. &ldquo;10.10.3&rdquo; and implement the <code>&lt;=&gt;</code> operator.</p>

<p>I&rsquo;m currently reading <code>Effective Ruby</code> by Peter Jones and this post is based on Item 13: Implement
Comparison via &ldquo;&lt;=>&rdquo; and the Comparable Module.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[You can't handle the truth]]></title>
    <link href="http://gregmoreno.ca/you-cant-handle-the-truth/"/>
    <updated>2016-02-15T16:21:58-08:00</updated>
    <id>http://gregmoreno.ca/you-cant-handle-the-truth</id>
    <content type="html"><![CDATA[<p>Quick question. What’s the output of this code in Ruby?</p>

<pre><code>amount = 0
if amount
  puts 'hey'
else
  puts ‘nah'
end
</code></pre>

<p>If you answered <code>nah</code>, you’re wrong. But it’s fine because this is one of the biggest gotchas for developers who are new to Ruby. Heck, even seasoned developers like myself sometimes forget this. I blame my college CS professors for putting too much <code>C</code> syntax in my brain.</p>

<p>Ruby has a simple rule for dealing with boolean values:  everything is true except <code>false</code> and <code>nil</code>.  This also means that every expression and object in Ruby can be evaluated against true or false. For example, you can have a method <code>find</code> that returns an object when it finds one or <code>nil</code> otherwise.</p>

<pre><code>if  o = Customer.find_by(email: ‘stevej@rip.com’)
  puts o.name
else
  puts ‘not found it'
end
</code></pre>

<p>But it’s a different story when returning a numeric value because 0 evaluates to true.</p>

<p><code>false</code> and <code>nil</code> can also be a common source of confusion because you have 2 values that can be false.  Consider the default behaviour of  Hash, which returns nil if the key does not exist. If you only factor in the <code>nil</code> scenario, you will have a problem when a key returns a <code>false</code> value - a common scenario with code that handles configuration or settings.
In the case below, this will output <code>missing key</code></p>

<pre><code>h = {'a' =&gt; 1, 'b' =&gt; false}
key = ‘b'
if h[key]
  puts 'found a value'
else
  puts 'missing key'
end
</code></pre>

<p>If that’s enough confusion for you, consider this:  <code>true</code>, <code>false</code>, and <code>nil</code> are just instances of a class.</p>

<pre><code>irb&gt; true.class
=&gt; TrueClass
irb&gt; false.class
=&gt; FalseClass
irb&gt; nil.class
=&gt; NilClass
</code></pre>

<p>They are global variables but you can’t set any value to it which is fine. Otherwise, there will be chaos!</p>

<pre><code>irb&gt; true = 1
SyntaxError: (irb):18: Can't assign to true
true = 1
</code></pre>

<p>But, this is Ruby and we can always introduce chaos. Matz, the creator of Ruby,  has given us this much power because he trusts that we know what we are doing.</p>

<pre><code>irb&gt; class Bad
irb&gt;   def ==(other)
irb&gt;     true
irb&gt;   end
irb&gt; end

irb&gt; false == Bad.new
=&gt; false
irb&gt; Bad.new == false
=&gt; true
</code></pre>

<p>What the heck just happened?  Well, <code>==</code> is just another method call - the first is for the <code>FalseClass</code> instance while the second is for the <code>Bad</code> instance.</p>

<p>If you have been using Ruby for a while and wants to become better at it, I suggest you
get a copy of <code>Effective Ruby</code> by Peter Jones.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails #permitted]]></title>
    <link href="http://gregmoreno.ca/rails-permitted/"/>
    <updated>2015-08-21T00:00:00-07:00</updated>
    <id>http://gregmoreno.ca/rails-permitted</id>
    <content type="html"><![CDATA[<p>I recently upgraded a personal app I use for learning new things in Rails. But when I upgraded from
4.1.4 to 4.1.12 I encountered this familiar error.</p>

<pre><code>Customer.where(auth.slice(:provider, :uid)).first_or_initialize
ActiveModel::ForbiddenAttributesError: ActiveModel::ForbiddenAttributesError
from /Users/greg/.rbenv/versions/2.1.2/lib/ruby/gems/2.1.0/gems/activemodel-4.1.12/lib/active_model/forbidden_attributes_protection.rb:21:in `sanitize_for_mass_assignment`
</code></pre>

<p>Now I remember. It&rsquo;s one of those mass assignments where you have to specify the &lsquo;permitted&rsquo; values before you can continue. In Rails 4, it&rsquo;s good practice
to whitelist the attributes you receive in the controller and it goes something like this:</p>

<pre><code>def user_params
  params.require(:user).permit(:username, :email, :password)
end

# somewhere in the controller
Customer.create(user_params)
</code></pre>

<p>Now, let&rsquo;s use this idiom. It should be easy, right?</p>

<pre><code>&gt; auth.permit(:provider, :uid)
=&gt; nil
</code></pre>

<p>Wait, that didn&rsquo;t go as expected. How about just simply composing the hash?</p>

<pre><code>&gt; Customer.where(provider: auth[:provider], uid: auth[:uid]).first_or_initialize
=&gt; #&lt;Customer:0x007fd9168ffa88&gt;
</code></pre>

<p>Interesting. #permit returns nil, using plain hash works, and #slice doesn&rsquo;t.</p>

<pre><code>&gt; auth.slice(:provider, :uid).class
=&gt; OmniAuth::AuthHash &lt; Hashie::Mash
</code></pre>

<p>It shouldn&rsquo;t matter what auth is as long as it behaves like what the Customer model expects. But what
does the Customer model expects? Actually, the error message is telling us what it expects. In Rails,
there is this module for mass assignment protection:</p>

<pre><code># https://github.com/rails/rails/blob/master/activemodel/lib/active_model/forbidden_attributes_protection.rb
module ActiveModel
  # Raised when forbidden attributes are used for mass assignment.
  #
  #   class Person &lt; ActiveRecord::Base
  #   end
  #
  #   params = ActionController::Parameters.new(name: 'Bob')
  #   Person.new(params)
  #   # =&gt; ActiveModel::ForbiddenAttributesError
  #
  #   params.permit!
  #   Person.new(params)
  #   # =&gt; #&lt;Person id: nil, name: "Bob"&gt;
  class ForbiddenAttributesError &lt; StandardError
  end

  module ForbiddenAttributesProtection # :nodoc:
    protected
      def sanitize_for_mass_assignment(attributes)
        if attributes.respond_to?(:permitted?) &amp;&amp; !attributes.permitted?
          raise ActiveModel::ForbiddenAttributesError
        else
          attributes
        end
      end
      alias :sanitize_forbidden_attributes :sanitize_for_mass_assignment
  end
end
</code></pre>

<p>Nothing fancy here. Rails does a simple check whether to allow mass assignment or not.</p>

<pre><code>&gt; auth.slice(:provider, :uid).permitted?
=&gt; false

&gt; { provider: auth[:provider], uid: auth[:uid] }.permitted?
NoMethodError: undefined method `permitted?' for {:provider=&gt;"facebook", :uid=&gt;"123"}:Hash
</code></pre>

<p>OmniAuth::AuthHash does not even allow it. Plain Hash works because it doesn&rsquo;t even respond to #permitted.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rebuild Rails Part 4]]></title>
    <link href="http://gregmoreno.ca/rebuild-rails-part4/"/>
    <updated>2014-11-24T00:00:00-08:00</updated>
    <id>http://gregmoreno.ca/rebuild-rails-part4</id>
    <content type="html"><![CDATA[<p>Now, it is time to build real pages in our super duper Tracks framework. We will support ERB and to do that
we need the <a href="https://rubygems.org/gems/erubis">erubis</a> gem.</p>

<pre><code># app/controllers/posts_controller.rb
class PostsController &lt; Tracks::Controller
  def index
    locals = { title: "/posts/index" }
    render template: "posts/index", locals: locals
  end
end

# app/views/posts/index.html.erb
hello from tracks &lt;%= title %&gt;

# lib/tracks/controller.rb
def render(options)
  template_name = options.fetch(:template)
  locals = options.fetch(:locals)

  filename = File.join "app/views", "#{template_name}.html.erb"
  template = File.read(filename)
  erb = Erubis::Eruby.new(template)
  erb.result locals
end

$ ruby spec/application_spec.rb
Run options: --seed 12593

# Running:

..

Finished in 0.020498s, 97.5705 runs/s, 195.1410 assertions/s.

2 runs, 4 assertions, 0 failures, 0 errors, 0 skips
</code></pre>

<p>Our tests show we are good but it&rsquo;s not even close to Rails' &ldquo;magic&rdquo;. First, let&rsquo;s
use the <code>controller/action</code> convention, i.e. if no template is passed to the <code>render</code> method,
we should use the <code>app/views/posts/index.html.erb</code> template. We also modify our <code>Controller</code> to save
the <code>env</code> data passed by <code>Rack</code> because we need to check the path.</p>

<pre><code># lib/tracks/controller.rb
module Tracks
  class Controller
    attr_reader :env, :controller_name, :action_name

    def initialize(env)
      @env = env
      extract_env_info
    end

    def extract_env_info
      _, @controller_name, @action_name, after = path_info.split("/")
    end

    def path_info
      env["PATH_INFO"]
    end

    def extract_template_name
      "#{controller_name}/#{action_name}"
    end
  end
end
</code></pre>

<p>We then update our <code>render</code> method to check for the template if it is not passed.</p>

<pre><code># lib/tracks/controller.rb
     def render(options)
-      template_name = options.fetch(:template)
+      template_name = options.fetch(:template) { extract_template_name }
       locals = options.fetch(:locals)

       filename = File.join "app/views", "#{template_name}.html.erb"
@@ -29,6 +43,5 @@ module Tracks
       erb.result locals
     end
</code></pre>

<p>Our next modification involves using the @instance_variables to pass values from the
controller to the view files. To do that, we just need to pass the current <code>binding</code> to
the <code>eruby</code> instance and it should pickup the instance variables we have in the controller.</p>

<p>In Rails, it is a bit more involved. There is a concept of <a href="https://github.com/rails/rails/blob/0c5552a3dd28e35cce64462765cc41c5355db0f1/actionpack/lib/abstract_controller/rendering.rb#L84-L86">view context</a>. Rails
collects the instance variables from the controller, then duplicates the values into the view context.
The Ruby methods <code>#instance_variables</code>, <code>#instance_variable_get</code>, <code>#instance_variable_set</code> allow
Rails to accomplish that.</p>

<pre><code>def render(options={})
  template_name = options.fetch(:template) { extract_template_name }
  filename = File.join "app/views", "#{template_name}.html.erb"
  template = File.read(filename)
  erb = Erubis::Eruby.new(template)
  erb.result(binding)
end
</code></pre>

<p>We also update our <code>render</code> method and controller because we do not need the <code>locals</code> parameter.</p>

<pre><code># app/controllers/posts_controller.rb
class PostsController &lt; Tracks::Controller
  def index
    @title = "/posts/index"
    render
  end
end

# app/views/posts/index.html.erb
hello from tracks &lt;%= @title %&gt;
</code></pre>

<p>We still have the extra <code>render</code> call in our controller. To remove it, we keep track of the call
to render and if there&rsquo;s no rendered result yet, we call <code>render</code>.</p>

<pre><code>diff --git i/app/controllers/posts_controller.rb w/app/controllers/posts_controller.rb
index f7883e3..d7aa012 100644
--- i/app/controllers/posts_controller.rb
+++ w/app/controllers/posts_controller.rb
@@ -1,6 +1,5 @@
 class PostsController &lt; Tracks::Controller
   def index
     @title = "/posts/index"
-    render
   end
 end
diff --git i/lib/tracks/controller.rb w/lib/tracks/controller.rb
index 0119c1b..3d5d75a 100644
--- i/lib/tracks/controller.rb
+++ w/lib/tracks/controller.rb
@@ -30,7 +30,12 @@ module Tracks

       controller_class_name = controller.capitalize + "Controller"
       controller_class = Object.const_get(controller_class_name)
-      controller_class.new(env).send(action)
+      controller_context = controller_class.new(env)
+      controller_context.send(action)
+
+      if controller_context.rendered_string.nil?
+        controller_context.render
+      end
+
+      controller_context.rendered_string
     end

     def render(options={})
@@ -38,7 +43,7 @@ module Tracks
       filename = File.join "app/views", "#{template_name}.html.erb"
       template = File.read(filename)
       erb = Erubis::Eruby.new(template)
-      erb.result(binding)
+      @rendered_string = erb.result(binding)
     end
</code></pre>

<p>We also update our controller and tests to cover the case of using <code>render</code> explicitly.</p>

<pre><code># app/controllers/posts_controller.rb
class PostsController &lt; Tracks::Controller
  def index
    @title = "/posts/index"
  end

  def show
    @title = "/posts/index"
    render template: "posts/index"
  end
end

# spec/application_spec.rb
require_relative "spec_helper"

describe CrazyApp::Application do
  include Rack::Test::Methods

  def app
    CrazyApp::Application
  end

  it "should respond with /" do
    get "/"
    last_response.ok?.must_equal true
    last_response.body.strip.must_equal "hello from index.html"
  end

  it "should respond with different path" do
    get "/posts/index"
    last_response.ok?.must_equal true
    last_response.body.strip.must_equal "hello from tracks /posts/index"
  end

  it "should respond with different template" do
    get "/posts/show"
    last_response.ok?.must_equal true
    last_response.body.strip.must_equal "hello from tracks /posts/index"
  end
end
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rebuild Rails Part 3]]></title>
    <link href="http://gregmoreno.ca/rebuild-rails-part3/"/>
    <updated>2014-11-20T00:00:00-08:00</updated>
    <id>http://gregmoreno.ca/rebuild-rails-part3</id>
    <content type="html"><![CDATA[<p>Let&rsquo;s continue our rebuild rails series by supporting controllers. We simplify things
by assuming a <code>controller/action</code> path format and only support <code>GET</code> request.</p>

<p>We adjust our <code>.call</code> implementation to handle the new path format. We also introduce
another method <code>#render_controller_action</code> that inspects the <code>path_info</code>
and instantiates the right controller using Rails <code>NameController</code> convention.</p>

<pre><code># lib/tracks.rb
def self.call(env)
  path_info = env["PATH_INFO"]
  if  path_info == "/"
    text = Tracks::Controller.render_default_root
  else
    text = Tracks::Controller.render_controller_action(env)
  end

  [200, {"Content-Type" =&gt; "text/html"}, [text] ]
end

# lib/tracks/controller.rb
def self.render_controller_action(env)
  path_info = env["PATH_INFO"]
  _, controller, action, after = path_info.split("/")

  controller_class_name = controller.capitalize + "Controller"
  controller_class = Object.const_get(controller_class_name)
  controller_class.new.send(action)
end

$ ruby spec/application_spec.rb
Run options: --seed 55835
# Running:

.E

Finished in 0.015837s, 126.2865 runs/s, 126.2865 assertions/s.

  1) Error:
CrazyApp::Application#test_0002_should respond with different path:
NameError: uninitialized constant PostsController
    /code/crazy/lib/tracks/controller.rb:13:in `const_get'
</code></pre>

<p>When we run the test, you see it failed on <code>PostsController</code> which is what
we expect since we haven&rsquo;t implemented <code>PostsController</code> yet. Let&rsquo;s add the
controller now.</p>

<pre><code># app/controllers/posts_controller.rb
class PostsController &lt; Tracks::Controller
  def index
    "hello from tracks /posts/index"
  end
end

# config/application.rb
require "./app/controllers/posts_controller"

$ ruby spec/application_spec.rb
Run options: --seed 2475

# Running:
..

Finished in 0.019152s, 104.4277 runs/s, 208.8555 assertions/s.

2 runs, 4 assertions, 0 failures, 0 errors, 0 skips
</code></pre>

<h3>Automatic loading</h3>

<p>Our tests pass but something&rsquo;s not right. In Rails, there is no need to require
every controller (or pretty much anything) to make it work. To support this feature in
our framework, we need 2 things:</p>

<ul>
<li>convert PostsController to posts_controller.rb; and</li>
<li>auto-require &lsquo;posts_controller&rsquo;</li>
</ul>


<p>To tie these 2 together, we tap into <code>Object.const_missing</code> so our framework would
know if a class has been used but not yet loaded.</p>

<p>We also update the <code>$LOAD_PATH</code> to include <code>app/controllers</code> folder so Ruby knows
where to look.</p>

<pre><code># lib/tracks.rb
require File.expand_path("../tracks/helper", __FILE__)
require File.expand_path("../tracks/object", __FILE__)

# config/application.rb
require './lib/tracks'
$LOAD_PATH &lt;&lt; File.expand_path("../../app/controllers", __FILE__)

module CrazyApp
  class Application &lt; Tracks::Application
  end
end

# lib/tracks/helper.rb
module Tracks
  module Helper
    def self.to_underscore(string)
      string.scan(/[A-Z][a-z]+/).
      join('_').
      downcase
    end
  end
end

# lib/tracks/object.rb
class Object
  def self.const_missing(c)
    require Tracks::Helper.to_underscore(c.to_s)
    const_get(c)
  end
end
</code></pre>

<p>Our implementation of <code>.to_underscore</code> is limited compared to what&rsquo;s supported in Rails.</p>

<pre><code>irb(main):019:0&gt; s = "PostsController"
=&gt; "PostsController"
irb(main):020:0&gt; s.scan(/[A-Z][a-z]+/).join('_').downcase
=&gt; "posts_controller"
</code></pre>

<p>Also, since we call <code>const_get</code> inside <code>const_missing</code>, you will run into serious
trouble if your file does not contain the expected class. Try changing the name of the
class inside <code>app/controllers/posts_controller.rb</code> into something else and you will get this
error.</p>

<pre><code>$ ruby spec/application_spec.rb
Run options: --seed 60433

# Running:

.E
Finished in 0.043152s, 46.3478 runs/s, 46.3478 assertions/s.

  1) Error:
CrazyApp::Application#test_0002_should respond with different path:
SystemStackError: stack level too deep
    /Users/greg/.rbenv/versions/2.0.0-p247/lib/ruby/2.0.0/forwardable.rb:174

2 runs, 2 assertions, 0 failures, 1 errors, 0 skips
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rebuild Rails Part 2]]></title>
    <link href="http://gregmoreno.ca/rebuild-rails-part2/"/>
    <updated>2014-11-19T00:00:00-08:00</updated>
    <id>http://gregmoreno.ca/rebuild-rails-part2</id>
    <content type="html"><![CDATA[<p>Before we continue with out rebuilding series, we should write some tests first :)</p>

<pre><code># spec/spec_helper.rb
ENV["RAILS_ENV"] ||= "test"

require "rack/test"
require "minitest/autorun"

require File.expand_path("../../config/application", __FILE__)


# spec/application_spec.rb
require_relative "spec_helper"

describe CrazyApp::Application do
  include Rack::Test::Methods

  def app
    CrazyApp::Application
  end

  it "should respond with /" do
    get "/"
    last_response.ok?.must_equal true
    last_response.body.strip.must_equal "hello from index.html"
  end

  it "should respond with different path" do
    get "/posts"
    last_response.ok?.must_equal true
    last_response.body.strip.must_equal "hello from tracks /posts"
  end

end
</code></pre>

<p>Just like your typical Rails test setup, we have a common <code>spec_helper</code> file. We use <code>minitest/autorun</code> which gives us
rspec-style DSL out of the box. For our test, we need <code>Rack::Test::Methods</code> to use <code>get</code> and other http methods. We also
need an <code>app</code> method that returns our Rack application to make the tests work.</p>

<pre><code>$ ruby spec/application_spec.rb
Run options: --seed 57256

# Running:
..

Finished in 0.015864s, 126.0716 runs/s, 252.1432 assertions/s.

2 runs, 4 assertions, 0 failures, 0 errors, 0 skips
</code></pre>

<p>We&rsquo;re all good. Awesome!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[#ruby Array of hashes quiz]]></title>
    <link href="http://gregmoreno.ca/ruby-array-of-hashes-quiz/"/>
    <updated>2014-11-17T00:00:00-08:00</updated>
    <id>http://gregmoreno.ca/ruby-array-of-hashes-quiz</id>
    <content type="html"><![CDATA[<p>Found this interesting ruby quiz from <a href="http://www.alphasights.com/careers/experienced/positions/new-york/6-ruby-on-rails-developer/apply">AlphaSights</a>.
Given an array of hashes, collapse into an array of hashes containing one entry per day.
And you can only reference the <code>:time</code> key and not the rest.</p>

<pre><code>log = [
  {time: 201201, x: 2},
  {time: 201201, y: 7},
  {time: 201201, z: 2},
  {time: 201202, a: 3},
  {time: 201202, b: 4},
  {time: 201202, c: 0}
]

# result should be
[
  {time: 201201, x: 2, y: 7, z: 2},
  {time: 201202, a: 3, b: 4, c: 0},
]
</code></pre>

<p>The first thing came to mind is to use <a href="http://www.ruby-doc.org/core-2.1.1/Enumerable.html#method-i-group_by"><code>Enumerable#group_by</code></a></p>

<pre><code>grouped = log.group_by { |i| i[:time] }
collapsed = grouped.collect do |t, a|
  no_time_h = a.inject({}) do |others, h|
    others.merge h.reject { |k, v| k.to_sym == :time }
  end

  {time: t}.merge(no_time_h)
end

puts collapsed.inspect
</code></pre>

<p>However, after reading this a couple of times, I still find the solution hard to follow.
For starter, <code>group_by</code> returns a hash where the values are an array of hashes which
brings me back to the original problem even though it is already grouped by time.
That I feel made the rest of the code more complicated.</p>

<pre><code># result of group_by
{201201=&gt;[{:time=&gt;201201, :x=&gt;2}, {:time=&gt;201201, :y=&gt;7}, {:time=&gt;201201, :z=&gt;2}], 201202=&gt;[{:time=&gt;201202, :a=&gt;3}, {:time=&gt;201202, :b=&gt;4}, {:time=&gt;201202, :c=&gt;0}]}
</code></pre>

<p>For my second version, I simply loop into the array and compose the hash using <code>:time</code> as the key.
Afterwards, use the <code>key-value</code> pair to compose the resulting array. The code may be longer but
it is more readable. Remember, <a href="https://www.safaribooksonline.com/library/view/beautiful-code/9780596510046/ch05.html">Correct, Beautiful, Fast (in That Order)</a>.</p>

<pre><code>hash_by_time = {}
log.each do |h|
  time = h[:time]
  others = h.reject { |k,v| k.to_sym == :time }

  if hash_by_time[time]
    hash_by_time[time].merge! others
  else
    hash_by_time[time] = others
  end
end

collapsed = hash_by_time.collect do |k, v|
  {time: k}.merge(v)
end
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[To the crazy ones]]></title>
    <link href="http://gregmoreno.ca/to-the-crazy-ones/"/>
    <updated>2014-11-16T00:00:00-08:00</updated>
    <id>http://gregmoreno.ca/to-the-crazy-ones</id>
    <content type="html"><![CDATA[<p>Though I&rsquo;ve seen this video a gazillion times, I still find it fresh and inspiring.</p>

<p><a href="http://www.youtube.com/watch?v=tjgtLSHhTPg" title="To The Crazy Ones"><img src="http://img.youtube.com/vi/tjgtLSHhTPg/0.jpg" alt="To The Crazy Ones" /></a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rebuild Rails Part 1]]></title>
    <link href="http://gregmoreno.ca/rebuild-rails-part1/"/>
    <updated>2014-11-16T00:00:00-08:00</updated>
    <id>http://gregmoreno.ca/rebuild-rails-part1</id>
    <content type="html"><![CDATA[<p>I have no plans to build another Rails-clone. Let&rsquo;s leave that work to other smarter people with more time.
But wouldn&rsquo;t it be fun if we can learn how Rails work under the hood and find out what makes it &ldquo;magical&rdquo;?
In this post I will only cover what happens when you typed that url until you get an HTML page. We&rsquo;ll simplify further by not using any database
access. If you would like to go deeper and wider, there is a <a href="https://rebuilding-rails.com/">book devoted entirely to it that I highly recommend</a>.</p>

<p>Let&rsquo;s call our application <code>CrazyApp</code> and let&rsquo;s build our first web app.</p>

<pre><code># config.ru
app =  proc do |env|
  [200, {'Content-Type' =&gt; 'text/html'}, ["hello from crazy app"] ]
end

run app

$ rackup config.ru -p 3000                                                                       [2.0.0-p247]
Thin web server (v1.6.2 codename Doc Brown)
Maximum connections set to 1024
Listening on 0.0.0.0:3000, CTRL+C to stop
127.0.0.1 - - [16/Nov/2014 20:42:02] "GET / HTTP/1.1" 200 - 0.0008
</code></pre>

<h3>It&rsquo;s all about the Rack</h3>

<p>Rack is a gem that sits between your framework (e.g. Rails) and Ruby-based
application servers like Thin, Puma, Unicorn, and WEBrick. When you type a url,
it goes through several layers of software until it hits our application which
in this case just returns a <code>hellow from crazy app</code>. Rack simplifies the interface
for web servers that we only have to worry about a few things to handle an HTTP request.</p>

<ul>
<li>HTTP status, e.g. 200</li>
<li>Response headers. There are lot of things you can set here but for now let&rsquo;s stick to content-type.</li>
<li>Actual content. In our case, an HTML page.</li>
</ul>


<p>Let&rsquo;s look at a boilerplate <code>config.ru</code> that you get from Rails.</p>

<pre><code># This file is used by Rack-based servers to start the application.

require ::File.expand_path('../config/environment',  __FILE__)
run Rails.application
</code></pre>

<p>One step in <a href="http://api.rubyonrails.org/classes/Rails/Application.html">Rails' bootup process</a> is to
define <code>Rails.application</code> as <code>class MyApp::Application &lt; Rails::Application</code>.
Both <code>Rails::Application</code> and <code>proc</code> provides a <code>call</code> method that is why both <code>config.ru</code> works.</p>

<p>Now, let&rsquo;s move our initial <code>config.ru</code> code to a different class that we can later extract into
a gem for our framework that we shall call <code>Tracks</code>. From here on, we shall follow Rails conventions
and build our gem from there.</p>

<pre><code># config.ru
require './config/application'
run CrazyApp::Application

# config/application.rb
require './lib/tracks'

module CrazyApp
  class Application &lt; Tracks::Application
  end
end

# lib/tracks.rb
module Tracks
  class Application
    def self.call(env)
      [200, {'Content-Type' =&gt; 'text/html'}, ["hello from tracks"] ]
    end
  end
end
</code></pre>

<p>Exit from your rackup process and re-run it because we are not supporting auto-reloading. This time you will see a message from our <code>Tracks</code> - the super awesome Rails-like framework.</p>

<h3>Render a default page</h3>

<p>We now introduce a very simple root controller and use it to render a default index page. We also modify our route handling
by inspecting the value in <code>env</code> object that Rack passed to our framework. The <code>env</code> packs a lot of information about
a request and for our routing, we are interested in <code>PATH_INFO</code> which is the url after the domain minus the query parameters.</p>

<pre><code># lib/tracks/controlle.rb
module Tracks
  class Controller
    def self.render_default_root
      filename = File.join('public', 'index.html')
      File.read filename
    end
  end
end


# lib/tracks.rb
require File.expand_path('../tracks/controller', __FILE__)

module Tracks
  class Application
    def self.call(env)
      path_info = env['PATH_INFO']
      if  path_info == '/'
        text = Tracks::Controller.render_default_root
      else
        text = "hello from tracks #{path_info}"
      end

      [200, {'Content-Type' =&gt; 'text/html'}, [text] ]
    end
  end
end
</code></pre>

<p>That&rsquo;s it for now. Next time, we will create our own controllers, action, and dynamic pages using ERB.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[#ruby Counting Vowels]]></title>
    <link href="http://gregmoreno.ca/ruby-minimal-code/"/>
    <updated>2014-11-13T00:00:00-08:00</updated>
    <id>http://gregmoreno.ca/ruby-minimal-code</id>
    <content type="html"><![CDATA[<p>Just saw a simple exercise in my Facebook feed and I thought I give it a shot. The problem is simple:</p>

<blockquote><p>Write a function that returns the number of vowels in the string.</p></blockquote>

<p>Here&rsquo;s my ruby solution:</p>

<pre><code>  require 'minitest/autorun'

  def vowel_count(s)
    vowels = %w[a e i o u]
    s.to_s.scan(/\w/).select { |i| i if vowels.include?(i.downcase) }.count
  end

  describe "#vowel_count" do
    it "should count upcase lowercase" do
      test = "I wanted to be an astronaut"
      vowel_count(test).must_equal 10
    end

    it "should be zero for empty string" do
      vowel_count("").must_equal 0
    end

    it "should be zero for nil" do
      vowel_count(nil).must_equal 0
    end
  end
</code></pre>

<p>Sounds simple, right? But there are subtle things you should watch out for.</p>

<ul>
<li><em>Upper and lower cases</em> may seem trivial but programmers are often bitten by these when comparing strings.</li>
<li>An initial solution would be to access each character via [index] and increment a counter for vowels.
Here is where familiarity with your language&rsquo;s libraries becomes useful.
While I didn&rsquo;t get the right method initially, I know Ruby&rsquo;s String library offers a way
to extract regex matches. From then on, it&rsquo;s just a matter of using <code>Enumerable#select</code>
which is a common Ruby idiom for filtering elements.</li>
<li>Having tests even for a simple code is a good discipline to have. My initial test only
covers the functional requirement. When I added the case of nil it quickly showed
the flaw in my code, which brings me to my next point.</li>
<li>Produce sensible results as much as possible. While you can argue the requirement
states a string and not a nil, it is good habit to defend your code in case the caller
passed an invalid value. Hence, I converted the parameter to a string to ensure the
rest of the code is working with a string object and it gives a sensible result even
if the passed parameter is not a string.</li>
</ul>


<h3>Minimalist testing</h3>

<p>If you are working with Rails' for a while, you probably been pampered with Rails seamless
integration with testing frameworks you&rsquo;ll be forgiven if you think these support
are only available within Rails.</p>

<p>Ruby comes with <code>minitest/autorun</code> that supports a minimalist testing framework. Just require in your code and you are
good to go with rspec-style testing right off the bat.</p>

<pre><code>$ ruby vowelcount.rb
Run options: --seed 47907

# Running:

...

Finished in 0.001155s, 2597.4026 runs/s, 2597.4026 assertions/s.

3 runs, 3 assertions, 0 failures, 0 errors, 0 skips
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[#hacking  Ansible]]></title>
    <link href="http://gregmoreno.ca/hacking-ansible/"/>
    <updated>2014-10-17T21:02:43-07:00</updated>
    <id>http://gregmoreno.ca/hacking-ansible</id>
    <content type="html"><![CDATA[<p>Before you continue, let me congratulate myself. It’s been years since I’ve written a post. Hooray! Also, thank you to <a href="https://github.com/radamanthus/ansible-rails">Rad</a> for guiding me on my Ansible adventure. The ansible code I reference here are <a href="https://github.com/gregmoreno/ansible-rails">available in github</a>.</p>

<p>There are tons of posts about Ansible already so this is more about gotchas I learned along the way.</p>

<h3>Variables</h3>

<p>Just like good coding, you should isolate things that will change. Store variables in vars/defaults.yml for things like initial database password, deployment directory, ruby version, and whatnot. I started out with using snake format but I later learned you can have a hierarchy for your variables as well, for example:</p>

<pre><code>app:
  name: google.app
</code></pre>

<p>Inside your tasks, you can reference it with . Of course, nothing prevents you from just simply naming your variable as app_name and use it as</p>

<h3>Hosts and groups</h3>

<p>You can use ansible to work on 1 or more servers at a time. These servers are specified in the hosts file (see hosts in the example). You can also group servers by using [groupname]. In the example below, you can have ansible target qa only (using the —limit option) and it will update the 2 servers you listed under the [qa] group.</p>

<pre><code>[local]
localhost ansible_python_interpreter=/usr/local/bin/python

[www]
www.yourapp.com

[staging]
staging.yourapp.com

[qa]
qa1.yourapp.com
qa2.yourapp.com
</code></pre>

<h3>Use roles</h3>

<p>Roles allow you to separate common tasks into sort of like modules giving you flexibility. Some use roles to group common tasks like ‘db’, ‘web’, etc. For starters like me and if you are playing with combining different software, I used roles to define specific software. I have a role named ‘mysql’, a role ‘nginx-puma’, or a role ‘nginx-passenger’. Over time, you may split the roles into functional distinctions like web, db, etc.</p>

<h3>Creating an EC2 instance</h3>

<p>In my example, just update the variables below (included in vars/defaults.yml) to suit your requirements.</p>

<pre><code>ec2_keypair: yourapp-www
ec2_instance_type: t1.micro
ec2_security_group: web-security-group
ec2_region: us-west-1
ec2_zone: us-west-1c
ec2_image: ami-f1fdfeb4 # Ubuntu Server 14.04 LTS (PV) 64-bit
ec2_instance_count: 1
</code></pre>

<p>You need your AWS_ACCESS_KEY, AWS_SECRET_KEY, and PEM file to create an instance. Creating the AWS access keys requires access to the IAM (Identity and Access Management).</p>

<p>When you’re ready, run the command:</p>

<pre><code>AWS_ACCESS_KEY="access" AWS_SECRET_KEY="secret" ansible-playbook -i hosts ec2.yml
</code></pre>

<p>I have set ec2.yml to run against ‘local’ group (specified in the ’hosts’ file) because you don’t have a host yet. The Ansible EC2 module is smart enough to know that you are still creating an instance at this point.</p>

<p>After running the playbook, notice that it creates a new entry in the [launched] group in your hosts file. The new entry points to the EC2 instance you just created. At this point, you now have a server to run the rest of the playbooks.</p>

<h3>Creating the deploy user</h3>

<p>When the instance is created, it would create a new user. In my project where I use Ubuntu, it creates an ‘ubuntu’ user. In other cases, it might only create ‘root’ user. Regardless, your next step is to create a ‘deploy’ user because it is not a good idea to keep using root. You can change the name of the deploy user (see vars/defaults.yml) but I prefer using ‘deploy’ because it is also the default user in capistrano and I’m a Rails guy.</p>

<pre><code>ansible-playbook -i hosts create-user.yml --user root --limit launched --private-key ~/.ssh/yourapp.pem
</code></pre>

<p>This playbook does several things:</p>

<ul>
<li>Creates the ‘deploy’ user.</li>
<li>Adds your ssh key to /home/deploy/.ssh/authorized_keys</li>
<li>Gives deploy sudo rights.</li>
<li>Disables ssh and password access for root.</li>
</ul>


<p>Note that I specified in the initial user ‘root’. Depending on the instance you just created it might be ‘ubuntu’ or some other initial user</p>

<h3>Creating an instance in other providers</h3>

<p>In Digital Ocean (and other similar providers), you can create an instance using their admin interface. The initial user is ‘root’ and you can specify a password and/or public key. If you forgot the public key, you must add it before you continue.</p>

<pre><code>scp ~/.ssh/id_rsa.pub root@yourapp.com:~/uploaded_key.pub
ssh root@staging.app.com
mkdir -m og-rwx .ssh
cat ~/uploaded_key.pub &gt;&gt; ~/.ssh/authorized_keys
</code></pre>

<h3>Bootstrapping</h3>

<p>Now that you have your deploy user, just run the command below, take a coffee, and come back after 30 mins. That’s how awesome ansible is.</p>

<pre><code>ansible-playbook -i hosts bootstrap.yml --limit launched
</code></pre>

<p>You may need to tweak the roles or update a specific server. For example, you’re testing an upgrade on a staging server. In that case, make sure you specify the corect host group in the —limit parameter</p>

<p>A few more things I learned with this exercise:</p>

<ul>
<li>I can set the file mode with mkdir.</li>
<li>Use <code>bash —login</code> to load login profile. When I ssh using ‘deploy@domain‘, my ruby gets loaded correctly. However, when using ansible (which uses ssh), my ruby is not loaded and thus, you will get errors like &lsquo;bundle not found&rsquo;.</li>
<li>I’m torn between using system ruby and chruby. On one hand, I feel like there is no need for chruby because this is a server and no need to switch rubies from time-to-time. On the other hand, why not try it and see how it works.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[#ruby method_missing gotchas]]></title>
    <link href="http://gregmoreno.ca/ruby-method-missing-gotchas/"/>
    <updated>2012-10-11T00:00:00-07:00</updated>
    <id>http://gregmoreno.ca/ruby-method-missing-gotchas</id>
    <content type="html"><![CDATA[<h3>Forgetting &lsquo;super&rsquo; with &lsquo;method_missing&rsquo;</h3>

<p>&lsquo;method_missing&rsquo; is one of Ruby&rsquo;s power that makes frameworks like Rails seem magical. When you call a method in an object (or &ldquo;send a message to the object&rdquo;), the object executes the first method it finds. If the object can&rsquo;t find the method, it complains. This is pretty much what every modern programming language does. Except in Ruby you can guard against a non-existent method call by having the method &lsquo;method_missing&rsquo; in your object. If you are using Rails, this technique enables dynamic record finders like User.find_by_first_name.</p>

<pre><code>require "rspec"

class RadioActive
  def to_format(format)
    format
  end

  def method_missing(name, *args)
    if name.to_s =~ /^to_(\w+)$/
      to_format($1)
    end
  end
end

describe RadioActive do
  it "should respond to to_format" do
    format = stub
    subject.to_format(format).should == format
  end

  it "should respond to to_other_format" do
    subject.to_other_format.should == "other_format"
  end

  it "should raise a method missing" do
    expect do
      subject.undefined_method
    end.to raise_error
  end
end
</code></pre>

<p>However, improper use of &lsquo;method_missing&rsquo; can introduce bugs in your code that would be hard to track. To illustrate, our example code above intercepts methods whose name are in the &lsquo;to_name&rsquo; format. It works fine as our tests tell us except when we try to call an undefined method that does not follow the &ldquo;to_name&rdquo; format. The default behavior for undefined method is for the object to raise a NoMethodError exception.</p>

<pre><code>$ rspec method_missing_gotcha-01.rb
..F

Failures:

  1) RadioActive should raise a method missing
     Failure/Error: expect do
       expected Exception but nothing was raised
     # ./method_missing_gotcha-01.rb:30:in `block (2 levels) in &lt;top (required)&gt;'

Finished in 0.00448 seconds
3 examples, 1 failure

Failed examples:

rspec ./method_missing_gotcha-01.rb:29 # RadioActive should raise a method missing
</code></pre>

<p>You can easily catch this bug if you have a test. It would be a different story if you just use your class straight away.</p>

<pre><code>irb(main):001:0&gt; require './method_missing_gotcha-01.rb'
=&gt; true
irb(main):002:0&gt; r = RadioActive.new
=&gt; #&lt;RadioActive:0x007fd232a4d8a8&gt;
irb(main):003:0&gt; r.to_format('json')
=&gt; "json"
irb(main):004:0&gt; r.to_json
=&gt; "json"
irb(main):005:0&gt; r.undefined
=&gt; nil
</code></pre>

<p>The undefined method just returns nil instead of raising an exception. When we defined our method_missing, we removed the default behavior accidentally. Oops!</p>

<p>Fortunately, the fix is easy. There is no need to raise the &lsquo;NoMethodError&rsquo; in your code. Instead, simply call &lsquo;super&rsquo; if you are not handling the method. Whether you have your own class or inheriting from another, do not forget to call &lsquo;super&rsquo; with your &lsquo;method_missing&rsquo;. And that would make our tests happy :)</p>

<pre><code>--- 1/method_missing_gotcha-01.rb
+++ 2/method_missing_gotcha-02.rb
@@ -9,6 +9,8 @@ class RadioActive
   def method_missing(name, *args)
     if name.to_s =~ /^to_(\w+)$/
       to_format($1)
+    else
+      super
     end
   end

$ rspec method_missing_gotcha-02.rb
...

Finished in 0.00414 seconds
3 examples, 0 failures
</code></pre>

<p>Calling &lsquo;super&rsquo; is not just for &lsquo;missing_method&rsquo;. You also need to do the same for the other hook methods like &lsquo;const_missing&rsquo;, &lsquo;append_features&rsquo;, or &lsquo;method_added&rsquo;.</p>

<h3>Forgetting respond_to?</h3>

<p>When we modified &lsquo;method_missing&rsquo;, we are essentially introducing ghost methods. They exist but you cannot see them. You can call them spirit methods if that suits your beliefs. In our example, we were able to use a method named &lsquo;to_json&rsquo; but if we look at the list of methods defined for RadioActive, we will not see a &lsquo;to_json&rsquo;.</p>

<pre><code>irb(main):002:0&gt; RadioActive.instance_methods(false)
=&gt; [:to_format, :method_missing]
irb(main):003:0&gt; r = RadioActive.new
=&gt; #&lt;RadioActive:0x007f88b2a151c0&gt;
irb(main):004:0&gt; r.respond_to?(:to_format)
=&gt; true
irb(main):005:0&gt; r.respond_to?(:to_json)
=&gt; false
</code></pre>

<p>Before we introduce a fix, let us first write a test that shows this bug. It&rsquo;s TDD time baby!</p>

<pre><code>@@ -32,4 +34,8 @@ describe RadioActive do
     end.to raise_error
   end

+  it "should respond_to? to_other format" do
+    subject.respond_to?(:to_other_format).should == true
+  end
+
 end

...F

Failures:

  1) RadioActive should respond_to? to_other format
     Failure/Error: subject.respond_to?(:to_other_format).should == true
       expected: true
            got: false (using ==)
     # ./method_missing_gotcha-02.rb:38:in `block (2 levels) in &lt;top (required)&gt;'

Finished in 0.00444 seconds
4 examples, 1 failure

Failed examples:

rspec ./method_missing_gotcha-02.rb:37 # RadioActive should respond_to? to_other format
</code></pre>

<p>The fix is every time you modify &lsquo;method_missing&rsquo;, you also need to update &lsquo;respond_to?&rsquo;. And don&rsquo;t forget to include &lsquo;super&rsquo;.</p>

<pre><code>+  def respond_to?(name)
+    !!(name.to_s =~ /^to_/ || super)
+  end
+
 end
</code></pre>

<p>And with that, we are all green.</p>

<pre><code>....

Finished in 0.00443 seconds
4 examples, 0 failures
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mining Twitter Data with Ruby - Visualizing User Mentions]]></title>
    <link href="http://gregmoreno.ca/mining-twitter-data-with-ruby-visualizing-user-mentions/"/>
    <updated>2012-09-20T20:53:45-07:00</updated>
    <id>http://gregmoreno.ca/mining-twitter-data-with-ruby-visualizing-user-mentions</id>
    <content type="html"><![CDATA[<p>In my <a href="http://gregmoreno.ca/2012/09/05/mining-twitter-data-with-ruby-mongodb-and-map-reduce/">previous post on mining twitter data with ruby</a>, we laid our foundation for collecting and analyzing Twitter updates. We stored these updates in <a href="http://www.mongodb.org/">MongoDB</a> and used map-reduce to implement a simple counting of tweets.  In this post, we&rsquo;ll show relationships between users based on mentions inside the tweet.  Fortunately for us, there is no need to parse each tweet just to get a list of users mentioned in the tweet because Twitter provides the &ldquo;entities.mentions&rdquo; field that contains what we need. After we collected the &ldquo;who mentions who&rdquo;, we then construct a directed graph to represent these relationships and convert them to an image so we can actually see it.</p>

<p>First, we start with the aggregation of mentions per user. We will use the same code base as last time. So if this is your first time, I recommend reading my previous related post or you can <a href="https://github.com/gregmoreno/tweetminer">follow the changes in Github</a>. Note to self:  Convert this to an actual gem in the next post.</p>

<pre><code># user_mention.rb
module UserMention

  def mentions_by_user
    map_command = %q{
      function() {
        var mentions = this.entities.user_mentions,
            users = [];
        if (mentions.length &amp;gt; 0) {
          for(i in mentions) {
            users.push(mentions[i].id_str)
          }

          emit(this.user.id_str, { mentions: users });
        }
      }
    }

   reduce_command = %q{
      function(key, values) {
        var users = [];

        for(i in values) {
          users = users.concat(values[i].mentions);
        }

        return { mentions: users };
      }
    }

    options = {:out =&gt; {:inline =&gt; 1}, :raw =&gt; true, :limit =&gt; 50 }
    statuses.map_reduce(map_command, reduce_command, options)
 end

end
</code></pre>

<p>We then again use map-reduce in MongoDB to implement our aggregation. Of course, this sort of thing can be done in Ruby directly but it would be way more efficient if we do it in MongoDB especially if you have a big collection to process.  Note that we limit the number of documents to process because we don&rsquo;t want our graph to look unrecognizable when we display it.</p>

<p>Now that we have our aggregation working, we construct a directed graph of user mentions using the <a href="http://rgl.rubyforge.org/rgl/index.html">rgl library</a>.</p>

<pre><code>require "bundler"
Bundler.require
require File.expand_path("../tweetminer", __FILE__)
settings = YAML.load_file File.expand_path("../mongo.yml", __FILE__)
miner = TweetMiner.new(settings)

require "rgl/adjacency"
require "rgl/dot"

graph = RGL::DirectedAdjacencyGraph.new
miner.mentions_by_user.fetch("results").each do |user|
  user.fetch("value").fetch("mentions").each do |mention|
    graph.add_edge(user.fetch("_id"), mention)
  end
end

# creates graph.dot, graph.png
graph.write_to_graphic_file
</code></pre>

<p>Once you have the user-mentions relationships in a graph, you can do interesting things like who is connected to somebody and the degrees of separation. But for now, we are just interested in showing who mentioned whom.  Our sample program saves the graph to the file graph.dot (<a href="http://en.wikipedia.org/wiki/DOT_language">using the DOT language</a>) and PNG output. But the default PNG output is not laid out nicely. Instead, we will use the &ldquo;<a href="http://www.graphviz.org/">neato</a>&rdquo;  program to convert our graph.dot into a nice looking PNG file.</p>

<pre><code>$ neato -Tpng graph.dot -o mentions.png
</code></pre>

<p>When you view &ldquo;mentions.png&rdquo;, you should see something similar as the one below. The labels are user IDs and the arrows show the mentioned users.</p>

<p>It would be cool to modify our program to use the users' avatars and also make it interactive. Or, use Twitter&rsquo;s streaming API and create an auto-update graph. I haven&rsquo;t done any research yet but I&rsquo;m sure there is some Javascript library out there that can help us display graph relationships.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mining Twitter data with Ruby, MongoDB and Map-Reduce]]></title>
    <link href="http://gregmoreno.ca/mining-twitter-data-with-ruby-mongodb-and-map-reduce/"/>
    <updated>2012-09-05T19:48:27-07:00</updated>
    <id>http://gregmoreno.ca/mining-twitter-data-with-ruby-mongodb-and-map-reduce</id>
    <content type="html"><![CDATA[<p>When is the best time to tweet? If you care about reaching a lot of users, the best time probably is when your followers are also tweeting. In this exercise,we will try to figure out the day and time users are the most active.  Since there is no way for us to do this for all users in the twitterverse, we will only use the users we follow as our sample.</p>

<h3>What do we need</h3>

<ul>
<li><a href="http://www.mongodb.org/">mongodb</a></li>
<li><a href="https://github.com/intridea/tweetstream">tweetstream</a> gem</li>
<li>awesome_print gem for awesome printing of Ruby objects</li>
<li>oauth credentials</li>
</ul>


<p>Visit <a href="http://dev.twitter.com"><a href="http://dev.twitter.com">http://dev.twitter.com</a></a> to get your oauth credentials. You just need to login, create an app, and the oauth credentials you need will be there. Copy the oauth settings to the twitter.yml file because that is where our sample code will be looking.</p>

<h3>Collect status updates</h3>

<p>We use the Tweetstream gem to access the <a href="https://dev.twitter.com/docs/streaming-apis">Twitter Streaming APIs</a> which allows our program to receive updates as they occur without the need to regularly poll Twitter.</p>

<pre><code># Collects user tweets and saves them to a mongodb
require 'bundler'
require File.dirname(__FILE__) + '/tweetminer'

Bundler.require

# We use the TweetStream gem to access Twitter's Streaming API
# https://github.com/intridea/tweetstream

TweetStream.configure do |config|
  settings = YAML.load_file File.dirname(__FILE__) + '/twitter.yml'

  config.consumer_key       = settings['consumer_key']
  config.consumer_secret    = settings['consumer_secret']
  config.oauth_token        = settings['oauth_token']
  config.oauth_token_secret = settings['oauth_token_secret']
end

settings = YAML.load_file File.dirname(__FILE__) + '/mongo.yml'
miner = TweetMiner.new(settings)stream = TweetStream::Client.new

stream.on_error do |msg|
  puts msg
end

stream.on_timeline_status do |status|
  miner.insert_status status
  print '.'
end

# Do not forget this to trigger the collection of tweets
stream.userstream
</code></pre>

<p>The code above handles the collection of status updates. The actual saving to mongodb is handled by the TweetMiner module.</p>

<pre><code># tweetminer.rb

require 'mongo'

class TweetMiner
  attr_writer :db_connector
  attr_reader :options

  def initialize(options)
    @options = options
  end

  def db
    @db ||= connect_to_db
  end

  def insert_status(status)
    statuses.insert status
  end

  def statuses
    @statuses ||= db['statuses']
  end

  private

  def connect_to_db
    db_connector.call(options['host'], options['port']).db(options['database'])
  end

  def db_connector
    @db_connector ||= Mongo::Connection.public_method :new
  end

 end
</code></pre>

<p>We will be modifying our code along the way and if you want follow each step, you can view this <a href="https://github.com/gregmoreno/tweetminer/commit/7d6e7ba3aa620c0a2ecc8495026056e043979510">commit at github</a>.</p>

<p>Depending on how active the people you follow, it may take a while before you get a good sample of tweets. Actually, it would be interesting if you could run the collection for several days.</p>

<p>Assuming we have several days' worth of data, let us proceed with the &ldquo;data mining&rdquo; part. Data mining would not be fun without a mention of map reduce - a strategy for data mining popularized by Google. The key innovation  with map reduce is its ability to take a query over a data set, divide it, and run it in parallel over many nodes. &ldquo;Counting&rdquo;, for example, is a task that fits nicely with the map reduce framework.  Imagine you and your friends are counting the number of people in a football stadium. First, you divide yourselves into 2 groups - group A counts the people in the lower deck while group B does the upper deck. Group A in turn divides the task into north, south, and endzones.  When group A is done counting, they tally all their results. After group B is done, they combine the results with group A for which the total gives us the number of people in the stadium.  Dividing your friends is the &ldquo;map&rdquo; part while the tallying of results is the &ldquo;reduce&rdquo; part.</p>

<h3>Updates per user</h3>

<p>First, let us do a simple task. Let us count the number of updates per user. We introduce a new module &lsquo;StatusCounter&rsquo; which we include in our TweetMiner module. We also add a new program to execute the map reduce task.</p>

<pre><code># counter.rb

require 'bundler'
Bundler.require
require File.dirname(__FILE__) + '/tweetminer'
settings = YAML.load_file File.dirname(__FILE__) + '/mongo.yml'

miner = TweetMiner.new(settings)

results = miner.status_count_by_user
ap results
</code></pre>

<p>Map reduce commands in mongodb are written in Javascript. When writing Javascript, just be conscious about string interpolation because Ruby sees it as a bunch of characters and nothing else. For the example below, we use the here document which interprets backslashes. In our later examples, we switch to single quotes when we use regular expressions within our Javascript.</p>

<pre><code>module StatusCounter
  class UserCounter
    def map_command
      &lt;&lt;-EOS
        function() {
          emit(this.user.id_str, 1);
        }
      EOS
    end

    def reduce_command
      &lt;&lt;-EOS
        function(key, values) {
          var count = 0;
          for(i in values) {
            count += values[i]
          }

          return count;
        }
      EOS
    end
  end

  def status_count_by_user
    counter = UserCounter.new
    statuses.map_reduce(counter.map_command, counter.reduce_command, default_mr_options)
  end

  def default_mr_options
    {:out =&gt; {:inline =&gt; 1}, :raw =&gt; true }
  end
 end
</code></pre>

<p><a href="https://github.com/gregmoreno/tweetminer/commit/ccc3c0b85f9023bdb04986b825b1932a815e35f2">Follow this commit</a> to view the changes from our previous examples.</p>

<p>When you run &lsquo;ruby counter.rb&rsquo;, you should see a similar screenshot as the one below:</p>

<h3>Tweets per Hour</h3>

<p>Now, let&rsquo;s do something a little bit harder than the previous example. This time,  we want to know how many tweets are posted per hour. Every tweet has a <em>created_at</em> field of type String. We then use a regular expression to extract the hour component.</p>

<pre><code>created_at:  'Tue Sep 04 22:04:40 +0000 2012'
regex:  (\d{2,2}):\d{2,2}:\d{2,2}
match: 22
</code></pre>

<p>The only significant change is the addition of a new map command. Note the reduce command did not change from the previous example. <a href="https://github.com/gregmoreno/tweetminer/commit/93d18d206c5ff0960c62d03cd1e2d3333a45e2fc">See the commit</a>.</p>

<pre><code>class HourOfDayCounter
  def map_command
    'function() {
      var re = /(\d{2,2}):\d{2,2}:\d{2,2}/;
      var hour = re.exec(this.created_at)[1];

      emit(hour, 1);
    }'
  end

  def reduce_command
    &amp;lt;&amp;lt;-EOS
      function(key, values) {
        var count = 0;

        for(i in values) {
          count += values[i]
        }

        return count;
      }
    EOS
  end

end

def status_count_by_hday
  counter = HourOfDayCounter.new
  statuses.map_reduce(counter.map_command, counter.reduce_command, default_mr_options)
end
</code></pre>

<p>Now run &lsquo;ruby counter.rb&rsquo; in the console with the new method and the result should be something like the one below.</p>

<p><img src="http://gregmoreno.ca/assets/20120905-nck36r98kaftn7i3fpfh4i6her.jpg" alt="" /></p>

<h3>Filtering records</h3>

<p>Our examples so far include every status since the beginning of time, which is pretty much useless. What we want is to apply the counting tasks to statuses posted the past 7 days, for example. MongoDB allows you to <a href="http://www.mongodb.org/display/DOCS/MapReduce">pass a query to your map-reduce</a> so you can filter the data where the map-reduce is applied. One problem though: <em>created_at</em> field is a string. To get around this, we introduce a new field <em>created_at_dt</em> which is of type Date.  You can hook it up in the <em>insert_status</em> method but since we already have our data, we instead run a query (using MongoDB console) to update our records. Please note the collection we are using is <em>statuses</em> and the new field is <em>created_at_dt</em>.</p>

<pre><code>var cursor = db.statuses.find({ created_at_dt: { $exists: false } });
while (cursor.hasNext()) {
  var doc = cursor.next();
  db.statuses.update({ _id : doc._id }, { $set : { created_at_dt : new Date(doc.created_at) } } )
}
</code></pre>

<p>Now, that we have a Date field, let&rsquo;s modify our method to include a <em>days_ago</em> parameter and a query in our map reduce.</p>

<pre><code>def status_count_by_hday(days_ago = 7)
  date     = Date.today - days_ago
  days_ago = Time.utc(date.year, date.month, date.day)
  query = { 'created_at_dt' =&gt; { '$gte' =&gt; days_ago } }

  options = default_mr_options.merge(:query =&gt; query)

  counter = HourOfDayCounter.new
  statuses.map_reduce(counter.map_command, counter.reduce_command, options)
end
</code></pre>

<p>Since we&rsquo;re now getting the hang of it, why don&rsquo;t we add another complexity. This time, let us count by day of the week and include a breakdown per hour.  Luckily for us,  the day of the week is also included in the created_at field and it is just a matter of extracting it.  Of course, if Twitter decides to change the format, this will break. Let&rsquo;s visit <a href="http://rubular.com">rubular.com</a> and  try our regular expression.</p>

<p><img src="http://gregmoreno.ca/assets/20120905-xfm9k1gsfrr7n4qnegue86pu1.jpg" alt="" /></p>

<p>Now that we have our regex working, let&rsquo;s include this in our new map command.</p>

<pre><code>def map_command
  'function() {
    var re = /(^\w{3,3}).+(\d{2,2}):\d{2,2}:\d{2,2}/;
    var matches = re.exec(this.created_at);

    var wday = matches[1],
        hday = matches[2];

    emit(wday, { count: 1, hdayBreakdown: [{ hday: hday, count: 1 }] });
  }'
end
</code></pre>

<p>Note the difference in the <em>emit</em> function from our previous examples. Before, we only emit a single numeric value that is why our reduce command is simple array loop.  This time, our reduce command requires more work.</p>

<pre><code>def reduce_command
  'function(key, values) {
     var total = 0,
         hdays = {},
         hdayBreakdown;

     for(i in values) {
       total += values[i].count

       hdayBreakdown = values[i].hdayBreakdown;

       for(j in hdayBreakdown) {
         hday  = hdayBreakdown[j].hday;
         count = hdayBreakdown[j].count;

         if( hdays[hday] == undefined ) {
           hdays[hday] = count;
         } else {
           hdays[hday] += count;
         }
       }
     }

     hdayBreakdown = [];
     for(k in hdays) {
       hdayBreakdown.push({ hday: k, count: hdays[k] })
     }

     return { count: total, hdayBreakdown: hdayBreakdown }
   }'
end
</code></pre>

<p>In our previous examples, the <em>values</em> parameter is a simple array of numeric values.  Now, it becomes an an array of properties. On top of that, one of the properties (i.e. hdayBreakdown) is also an array.  If everything works according to plan, you should see something like the image below when you run collect.rb.</p>

<p><img src="http://gregmoreno.ca/assets/20120905-xpffryewtqchu875ap9fnk4kha.jpg" alt="" /></p>

<p>Did you have fun? I hope so :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Adding keyboard shortcuts in web pages]]></title>
    <link href="http://gregmoreno.ca/adding-keyboard-shortcuts-in-web-pages/"/>
    <updated>2012-08-30T20:52:53-07:00</updated>
    <id>http://gregmoreno.ca/adding-keyboard-shortcuts-in-web-pages</id>
    <content type="html"><![CDATA[<p>Adding keyboard shortcuts to interact with your web pages seems like a useless feature when the rest of the world is using a mouse. But for a programmer who wants everything to be a few keystrokes away, keyboard shortcuts are very handy.</p>

<p>In this tutorial, we will add a simple scrolling shortcuts to our webpage.  This is just to illustrate what is possible. So please, do not copy-and-paste this to your production code.</p>

<h3>What do we need?</h3>

<ul>
<li><a href="http://jquery.com/">jquery</a></li>
<li><a href="http://www.sinatrarb.com/">sinatra</a></li>
<li><a href="http://coffeescript.org/">coffeescript</a></li>
</ul>


<p>Actually, the only critical piece we need is jQuery and knowledge of Javascript. However, since I am more of a Ruby guy, we will use Sinatra to build the page and CoffeeScript to write the Javascript.</p>

<h3>Build the pages</h3>

<p>The screenshot below (left side) shows how our directory structure would look like. It is pretty much a standard Sinatra structure.</p>

<p>Our HTML page displays 10 entries where each is grouped under a &ldquo;div&rdquo; element with an  &ldquo;.entry&rdquo; class and an  ID.  We also add in some styling in our page to distinguish each entry.</p>

<pre><code>&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta http-equiv="content-type" content="text/html; charset=utf-8" /&gt;
  &lt;title&gt;Index&lt;/title&gt;
  &lt;link rel="stylesheet" href="css/style.css"/&gt; &lt;script type="text/javascript" charset="utf-8" src="http://code.jquery.com/jquery-1.7.1.min.js"&gt;&lt;/script&gt;
  &lt;script type="text/javascript" charset="utf-8" src="js/app.js"&gt;
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;% 1.upto(10) do |i| %&gt;
    &lt;div id="&lt;%= "entry_#{i}" %&gt;"class="entry"&gt;
      &lt;%= "Title #{i}" %&gt;
      &lt;p&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.&lt;/p&gt;
    &lt;/div&gt;
  &lt;% end %&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>If everything is setup correctly, you should be able to run the app and see 10 entries.</p>

<pre><code>$ ruby app.rb
[2012-08-30 13:48:44] INFO WEBrick 1.3.1
[2012-08-30 13:48:44] INFO ruby 1.9.2 (2012-04-20) [x86_64-darwin12.1.0]
== Sinatra/1.3.3 has taken the stage on 4567 for development with backup from WEBrick
[2012-08-30 13:48:44] INFO WEBrick::HTTPServer#start: pid=12415 port=4567
</code></pre>

<p>Now for the juicy part. When the user presses &lsquo;j&rsquo;, we will scroll to the next entry while &lsquo;k&rsquo; scrolls to the previous. If you are a Vim user, you know why.</p>

<pre><code>current_entry = -1

$(document).keydown (e) -&gt;
  switch(e.keyCode)
  when 74 then scroll_to_next() # j
  when 75 then scroll_to_previous() # k

scroll_to_next = -&gt;
  #alert "scroll to next"
  current_entry++
  scroll_to_entry(current_entry)

scroll_to_previous = -&gt;
  if current_entry &gt; 0
    current_entry–
  scroll_to_entry(current_entry)

scroll_to_entry = (entry) -&gt;
  # Get the element we need to scroll to
  id = $(".entry")[entry].id
  $("html, body").animate { scrollTop: $("##{id}").offset().top }, "slow"
</code></pre>

<p>That&rsquo;s it! As I&rsquo;ve mentioned before, this is not production ready. For example, the shortcut should not interfere with other actions in your page like when the user is interacting with an input field. This also assumes the current visible entry is the first one.</p>

<p>This post is based from the book <a href="http://webdevelopmentrecipes.com/">Web Development Recipes</a>. If you are looking for quick reference on how to improve your project, I suggest reading the book.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to create a wrapper gem for service APIs - part 1]]></title>
    <link href="http://gregmoreno.ca/how-to-create-a-wrapper-gem-for-service-apis-part-1/"/>
    <updated>2012-06-07T00:41:01-07:00</updated>
    <id>http://gregmoreno.ca/how-to-create-a-wrapper-gem-for-service-apis-part-1</id>
    <content type="html"><![CDATA[<p>APIs are getting more and more popular as apps and services move to the cloud. Whenever you need to integrate a popular web service API into your Ruby app, 99.99% of the time there already exists a gem ready for use. That is a testament to how active Ruby developers are in supporting the community.</p>

<p>Even if integrating with the popular APIs is not in your radar, you may still have a need to create an API wrapper for internal use. For example, if your Rails application has grown tremendously (congratulations!), you may eventually need to adopt a services architecture to support upcoming features and make things manageable.</p>

<p>I created the <a href="https://github.com/gregmoreno/openamplify">gem for the Open Amplify API</a> as part of my exploration to data mining. When I first created it, my primary goal was simply to wrap the API. Though I still didn&rsquo;t write spaghetti code, it wasn&rsquo;t a good example of structured code either. Two years later (yep, that&rsquo;s how long I let the code rot), I decided to re-write the gem and adopt the architecture from the Twitter gem. It was a good exercise because not only I updated the gem for the newest API version, I also learned a great deal on how to write a gem.</p>

<h3>Setup the project</h3>

<p>We will create a wrapper for the fictitious Awesome API and thus call our gem &lsquo;awesome&rsquo;. To get things started, let&rsquo;s use bundler to set up our initial code.</p>

<pre><code>$&gt; bundle gem awesome
create awesome/Gemfile
create awesome/Rakefile
create awesome/LICENSE
create awesome/README.md
create awesome/.gitignore
create awesome/awesome.gemspec
create awesome/lib/awesome.rb
create awesome/lib/awesome/version.rb
Initializating git repo in /Users/greg/dev/code/awesome
</code></pre>

<p>This is the standard directory structure and naming convention of Ruby gems. The files Gemfile, Rakefile, and .gitignore are not necessary but they would be very useful while developing your gem.</p>

<h3>Gem dependencies</h3>

<p>All gem dependencies should go into awesome.gemspec and not in Gemfile. Inside your Gemfile, the line &lsquo;gemspec&rsquo; takes care of identifying the gems you needed in your local.</p>

<pre><code>$&gt; more Gemfile
source 'https://rubygems.org'

# Specify your gem's dependencies in awesome.gemspec
gemspec
</code></pre>

<h3>Versioning</h3>

<p>You specify the version of your gem inside lib/awesome/version.rb</p>

<pre><code>$&gt; more lib/awesome/version.rb
module Awesome
  VERSION = "0.0.1"
end
</code></pre>

<p>You may be wondering how is this used by the gem. Take a peek at awesome.gemspec and you&rsquo;ll see that Awesome::VERSION is used by the .gemspec file.</p>

<pre><code>$&gt; more awesome.gemspec
require File.expand_path('../lib/awesome/version', __FILE__)

Gem::Specification.new do |gem|
gem.authors = ["Greg Moreno"]
gem.email = ["greg.moreno@gmail.com"]
gem.description = %q{TODO: Write a gem description}
gem.summary = %q{TODO: Write a gem summary}
gem.homepage = ""

gem.files = `git ls-files`.split($\)
gem.executables = gem.files.grep(%r{^bin/}).map{ |f| File.basename(f) }
gem.test_files = gem.files.grep(%r{^(test|spec|features)/})
gem.name = "awesome"
gem.require_paths = ["lib"]
gem.version = Awesome::VERSION
end
</code></pre>

<h3>Additional modules and classes</h3>

<p>You can write all your code in the file lib/awesome.rb and it would still work. However, in the spirit of making code maintainable, it is highly recommended that you put your classes and modules under the directory lib/awesome just like what we did with lib/awesome/version.rb</p>

<h3>Testing the gem</h3>

<p>We will use minitest but you can always use any test framework you prefer. For our test setup, we need to do the ff:</p>

<ul>
<li>Setup our test directory manually since bundler didn&rsquo;t do this for us.</li>
<li>Create a rake task to run our tests.</li>
<li>Specify gem dependencies in our common test helper file.</li>
</ul>


<p>And the steps and code below.</p>

<pre><code>$&gt; mkdir test
$&gt; touch test/helper.rb
$&gt; mkdir test/awesome
$&gt; touch test/awesome/awesome_test.rb

# Rakefile
require 'bundler/gem_tasks'

require 'rake/testtask'
Rake::TestTask.new do |test|
  test.libs &lt;&lt; 'lib' &lt;&lt; 'test'
  test.ruby_opts &lt;&lt; "-rubygems"
  test.pattern = 'test/**/*_test.rb'
  test.verbose = true
end

# test/helper.rb
require 'awesome'
require 'minitest/spec'
require 'minitest/autorun'
</code></pre>

<p>Now that we have our testing in place, let&rsquo;s write a simple test and see if everything works.</p>

<pre><code># test/awesome/awesome_test.rb
require 'helper'

describe Awesome do
  it 'should have a version' do
    Awesome::VERSION.wont_be_nil
  end
end

# Then, let's run the test
$&gt; rake test
(in /Users/greg/dev/code/awesome)
/Users/greg/.rbenv/versions/1.9.2-p290/bin/ruby -I"lib:lib:test" -rubygems "/Users/greg/.rbenv/versions/1.9.2-p290/lib/ruby/1.9.1/rake/rake_test_loader.rb" "test/awesome/awesome_test.rb"
Loaded suite /Users/greg/.rbenv/versions/1.9.2-p290/lib/ruby/1.9.1/rake/rake_test_loader
Started
.
Finished in 0.000695 seconds.

1 tests, 1 assertions, 0 failures, 0 errors, 0 skips

Test run options: --seed 55984
</code></pre>

<p>Perfect! Now, let&rsquo;s start working on the juicy parts of our gem.</p>

<h3>Configuration</h3>

<p>Every webservice API would definitely require a per-user configuration and your gem should be able to support that. For example in the Twitter gem, some methods require authentication and you setup the default configuration with this:</p>

<pre><code>Twitter.configure do |config|
  config.consumer_key = YOUR_CONSUMER_KEY
  config.consumer_secret = YOUR_CONSUMER_SECRET
  config.oauth_token = YOUR_OAUTH_TOKEN
  config.oauth_token_secret = YOUR_OAUTH_TOKEN_SECRET
end
</code></pre>

<p>Every API has different options but if you are wrapping a webservice, the options often fall into two categories - connections and functional options. For example,  connection-related options include the endpoint, user agent, and authentication keys while functional options include request format (e.g. json), number of pages to return and other parameters required by specific API functions. In some APIs, the  api key is passed as a parameter to GET calls so while it may be connection-related, it is better to group it with parameter options so you can easily encode all parameters in a single call.Our Awesome API is simple and will not deal with OAuth like the Twitter gem does. For the configuration, we should be able to do this:</p>

<pre><code>Awesome.api_key = 'YOUR_API_KEY'
Awesome.format = :json
# Other options are: user_agent, method
</code></pre>

<p>Now, let&rsquo;s write some tests. Of course, these should fail at first :)</p>

<pre><code># test/awesome/configuration_test.rbrequire 'helper'

describe 'configuration' do
  describe '.api_key' do
    it 'should return default key' do
      Awesome.api_key.must_equal Awesome::Configuration::DEFAULT_API_KEY
    end
  end

  describe '.format' do
    it 'should return default format' do
      Awesome.format.must_equal Awesome::Configuration::DEFAULT_FORMAT
    end
  end

  describe '.user_agent' do
    it 'should return default user agent' do
      Awesome.user_agent.must_equal Awesome::Configuration::DEFAULT_USER_AGENT
    end
  end

  describe '.method' do
    it 'should return default http method' do
      Awesome.method.must_equal Awesome::Configuration::DEFAULT_METHOD
    end
  end
end
</code></pre>

<p>As I mentioned before, the best way to write your gem (or any program for that matter) is to cleary separate the functionalities into modules and classes. In our case, we will put all configuration defaults inside a module (i.e. lib/awesome/configuration.rb). We also want to provide class methods for the module Awesome which we can easily do using Ruby&rsquo;s &lsquo;extend&rsquo;.</p>

<pre><code># lib/awesome/configuration.rb

module Awesome
  module Configuration
    VALID_CONNECTION_KEYS = [:endpoint, :user_agent, :method].freeze
    VALID_OPTIONS_KEYS = [:api_key, :format].freeze
    VALID_CONFIG_KEYS = VALID_CONNECTION_KEYS + VALID_OPTIONS_KEYS

    DEFAULT_ENDPOINT = 'http://awesome.dev/api'
    DEFAULT_METHOD = :get
    DEFAULT_USER_AGENT = "Awesome API Ruby Gem #{Awesome::VERSION}".freeze

    DEFAULT_API_KEY = nil
    DEFAULT_FORMAT = :json

    # Build accessor methods for every config options so we can do this, for example:
    # Awesome.format = :xml
    attr_accessor *VALID_CONFIG_KEYS

    # Make sure we have the default values set when we get 'extended'
    def self.extended(base)
      base.reset
    end

    def reset
      self.endpoint = DEFAULT_ENDPOINT
      self.method = DEFAULT_METHOD
      self.user_agent = DEFAULT_USER_AGENT

      self.api_key = DEFAULT_API_KEY
      self.format = DEFAULT_FORMAT
    end

  end # Configuration
end

# lib/awesome.rb
require 'awesome/version'
require 'awesome/configuration'

module Awesome
  extend Configuration
end

$&gt; rake test
(in /Users/greg/dev/code/awesome)
/Users/greg/.rbenv/versions/1.9.2-p290/bin/ruby -I"lib:lib:test" -rubygems "/Users/greg/.rbenv/versions/1.9.2-p290/lib/ruby/1.9.1/rake/rake_test_loader.rb" "test/awesome/awesome_test.rb" "test/awesome/configuration_test.rb"
Loaded suite /Users/greg/.rbenv/versions/1.9.2-p290/lib/ruby/1.9.1/rake/rake_test_loader
Started
.....
Finished in 0.001600 seconds.

5 tests, 5 assertions, 0 failures, 0 errors, 0 skips
</code></pre>

<p>Our gem will not be awesome if we don&rsquo;t support a &lsquo;configure&rsquo; block like what the Twitter gem does. We want to setup the configuration like this:</p>

<pre><code>Awesome.configure do |config|
  config.api_key = 'YOUR_API_KEY'
  config.method = :post
  config.format = :json
end
</code></pre>

<p>Fortunately, it&rsquo;s an easy fix. We just need to add a &lsquo;configure&rsquo; method to the Configuration module. We also update our tests to make sure this new method works.</p>

<pre><code># lib/awesome/configuration.rb
def configure
  yield self
end

# test/awesome/configuration_test.rb
after do
  Awesome.reset
end

describe '.configure' do
  Awesome::Configuration::VALID_CONFIG_KEYS.each do |key|
    it "should set the #{key}" do
      Awesome.configure do |config|
        config.send("#{key}=", key)
        Awesome.send(key).must_equal key
      end
    end
  end
end
</code></pre>

<p>Before we move on, let&rsquo;s take a second look at our configuration tests. We have tests for checking default values and setting-up new ones.  What if we added a new configuration key for our gem? The &lsquo;configure&rsquo; tests will be able to handle the new key but we still have to add another test for checking the default value. And we don&rsquo;t want to right another test code, right?  More importantly, we don&rsquo;t want our tests to yield false positives. If we fail to add the &lsquo;default value&rsquo; check, our tests will still pass even though  we forgot to set a default value.Let us remove all our default value tests and replace it with code that relies on VALID_CONFIG_KEYS instead.</p>

<pre><code># test/awesome/configuration_test.rb
Awesome::Configuration::VALID_CONFIG_KEYS.each do |key|
  describe ".#{key}" do
    it 'should return the default value' do
      Awesome.send(key).must_equal Awesome::Configuration.const_get("DEFAULT_#{key.upcase}")
    end
  end
end

$&gt; rake test
(in /Users/greg/dev/code/awesome)
/Users/greg/.rbenv/versions/1.9.2-p290/bin/ruby -I"lib:lib:test" -rubygems "/Users/greg/.rbenv/versions/1.9.2-p290/lib/ruby/1.9.1/rake/rake_test_loader.rb" "test/awesome/awesome_test.rb" "test/awesome/configuration_test.rb"
Loaded suite /Users/greg/.rbenv/versions/1.9.2-p290/lib/ruby/1.9.1/rake/rake_test_loader
Started
...........
Finished in 0.002935 seconds.

11 tests, 11 assertions, 0 failures, 0 errors, 0 skips

Test run options: --seed 21540
</code></pre>

<h3>Configuring clients</h3>

<p>Our end goal is to wrap API calls that fits nicely into our application and the common approach to do that is to wrap the API calls under a &lsquo;Client&rsquo; class. Depending on the size of the API you want to support, the Client class maybe delegating the method calls to other classes and modules but from the point of view your program, the action happens inside the Client class. There are two ways to configure the Client class:</p>

<ul>
<li>It inherits the configuration values defined in the Awesome module;</li>
<li><p>It overrides the configuration values per client</p>

<p>  # Use the values defined in the Awesome module
  client = Awesome::Client.new
  client.make_me_awesome(&lsquo;gregmoreno&rsquo;)</p>

<p>  client_xml = Awesome::Client.new :format => :xml
  client_json = Awesome::Client.new :format => :json</p></li>
</ul>


<p>We are not going to show our tests in here but if you are interested, you can view the <a href="https://github.com/gregmoreno/awesome/blob/master/test/awesome/client_test.rb">test code from the github</a> repository. Instead, we show the code that handles the two scenarios for client configuration.</p>

<pre><code># lib/awesome/client.rb

module Awesome
  class Client

    # Define the same set of accessors as the Awesome module
    attr_accessor *Configuration::VALID_CONFIG_KEYS

    def initialize(options={})
      # Merge the config values from the module and those passed
      # to the client.
      merged_options = Awesome.options.merge(options)

      # Copy the merged values to this client and ignore those
      # not part of our configuration
      Configuration::VALID_CONFIG_KEYS.each do |key|
        send("#{key}=", merged_options[key])
      end
    end

  end # Client
end
</code></pre>

<p>We also need to update our Awesome module. First, we need to require the new file  awesome/client.rb so it will be loaded when we require the gem.  Second, we need to implement a method that returns all the configuration values inside the Awesome module. Since this is still about configuration, our new method should go inside the Configuration module.</p>

<pre><code># lib/awesome/configuration.rb
def options
  Hash[ * VALID_CONFIG_KEYS.map { |key| [key, send(key)] }.flatten ]
end
</code></pre>

<p>We&rsquo;re finally done with the configuration part of our gem. I know it&rsquo;s a lot of work for a simple task but we managed to put a good structure in our code. Plus, we learned how to make our tests less brittle, and use Ruby&rsquo;s awesome power to make our code better.   In our next installment, we&rsquo;ll discuss requests and error handling.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Create your own Rails 3 engine]]></title>
    <link href="http://gregmoreno.ca/create-your-own-rails-3-engine/"/>
    <updated>2012-05-29T22:47:53-07:00</updated>
    <id>http://gregmoreno.ca/create-your-own-rails-3-engine</id>
    <content type="html"><![CDATA[<p>Engine is an interesting feature of Rails. Engines are miniature applications that live inside your application and they have structure that you would normally find in a typical Rails application. If you have used the Devise gem, which itself is an engine, you know the benefits of being able to add functionality to your application with just a few lines of code. Another great benefit of engines is when you or your team are maintaining a number of applications the common functionalities can be extracted into engines.</p>

<p>Engines are already available prior to Rails 3 but it is not a core feature of the framework. As such, engine developers resorted to monkey-patching which, oftentimes, lead to engines breaking when Rails gets updated. In Rails 3.1, engines are now supported by the framework and there is now a clealy defined place where to hook your engines into Rails.</p>

<p>Now, let us go through the steps of building a simple engine. We will be working on authentication engine (like Devise) that allows users of your application to use their Twitter or Facebook credentials.</p>

<pre><code># This is the app that will use our engine
$&gt; rails new social_app

# This is our engine
$&gt; rails plugin new undevise --mountable
</code></pre>

<p>The –mountable option tells Rails you want to generate a mountable plugin, commonly known as engine. When you look at the directory structure of your engine, it is much different from your Rails app. The engine has controllers, models, views, mailers, lib, and even its own config/routes.rb (didn’t we just said it is a miniature Rails app).</p>

<h3>Include the engine in your app</h3>

<p>Just like any gem, you should update your app’s Gemfile to use the engine we created.</p>

<pre><code># social_app/Gemfile
gem 'undevise', :path =&gt; '../undevise'
</code></pre>

<p>Of course, you can set :path to any location or if it is in a git repository, you can use the :git option. If you are developing your engine alongside your app, a better approach is to use gem groups in your Gemfile. For example:</p>

<pre><code>group :development do
  gem 'undevise', :path =&gt; '../undevise'
end

group :production do
  gem 'undevise', :git =&gt; 'git://github.com/yourname/undevise.git'
end
</code></pre>

<p>After adding the engine in your Gemfile, let’s make sure all dependencies are available for the application. If everything works, you should be able to see a reference to undevise inside Gemfile.lock</p>

<pre><code>$&gt; cd social_app
$&gt; bundle install
$&gt; more Gemfile.lock
PATH
  remote: ../undevise
  specs:
    undevise (0.0.1)
      rails (~&gt; 3.2.1)
</code></pre>

<h3>Mount the engine</h3>

<p>Next, we will mount the engine and see if we can route requests to it. What this does is make sure requests starting with /auth will be passed to our engine.</p>

<pre><code># social_app/config/routes.rb
SocialApp::Application.routes.draw do
  mount Undevise::Engine, :at =&gt; '/auth'
end

# Run the social app. Make sure you are in the social_app directory.
$&gt; rails s

# Then visit http://localhost:3000/auth
</code></pre>

<p>When you visit ‘/auth‘, you will get a routing error because you haven’t defined any routes in your engine yet.</p>

<pre><code># undevise/config/routes.rb
Undevise::Engine.routes.draw do
  root :to =&gt; 'auth#index'
end
</code></pre>

<p>Remember even though your engine is mounted at ‘/auth’, what your engine sees is the path after the ‘/auth’. Routes in engines are namespaced to avoid conflicts with your app. You can change the mounted path in your Rails app anytime and your engine wouldn’t care. Let’s try again and see what Rails would tell us.</p>

<pre><code>$&gt; cd social_app
$&gt; rails s
</code></pre>

<p>Perfect! Now we know the request is being passed to our engine. We now just have to define our controller.</p>

<pre><code>$ cd undevise
$ rails g controller auth

# undevise/app/controllers/undevise/auth_controller.rb
module Undevise
  class AuthController &lt; ApplicationController
    def index
      render :text =&gt; 'Hello world'
    end

  end
end

# Now, visit http://localhost:3000/auth
</code></pre>

<p>Cool! We have the obligatory hello world program working. At the the risk of sounding like a broken record, remember your engine code should be namespaced. If you forget this, strange things will happen to your application and Rails will not usually complain about it.</p>

<h3>Gem dependencies</h3>

<p>I’m sure your idea for an engine is very far from what we have shown so far. When you generate an engine, it also creates a .gemspec file. While in your Rails app you list the gems in Gemfile, in your engine you list the gems inside the .gemspec file. This can be confusing because the engine also contains a Gemfile.</p>

<pre><code>$&gt; cd undevise
$&gt; more Gemfile

source "http://rubygems.org"

# Declare your gem's dependencies in undevise.gemspec.
# Bundler will treat runtime dependencies like base dependencies, and
# development dependencies will be added by default to the :development group.
gemspec
</code></pre>

<p>As you can see, there is no need to list the gems your engine needs in the Gemfile. The line ‘gemspec’ makes sure the gems you listed in your .gemspec file are installed when you run bundle install.</p>

<p>Now, let’s add some gems in our engine and see how it will affect our Rails app.</p>

<pre><code># undevise/undevise.gemspec
s.add_dependency "rails", "~&gt; 3.2.1"
s.add_dependency "omniauth"
s.add_dependency "omniauth-twitter"
s.add_dependency "omniauth-facebook"


$ cd social_app
$ bundle install
$ more Gemfile.lock
PATH
  remote: ../undevise
  specs:
    undevise (0.0.1)
      omniauth
      omniauth-facebook
      omniauth-twitter
      rails (~&gt; 3.2.1)
</code></pre>

<p>Here we can see the gems we specifed in undevise/undevise.gemspec are also included in the main Rails app.</p>

<h3>Configure OmniAuth</h3>

<p>If you are using omniauth directly in your app, your will configuration will definitely be in the file config/initializers/omniauth.rb. Since our engine is pretty much just another Rails app, it will also have its own config/initializers/omniauth.rb file. The only consideration with regards to the configuration is where would the Twitter or Facebook credentials be located. You definitely don’t want to embed it in your engine.</p>

<p>Our solution is to store the credentials inside a config/twitter.yml file (or config/facebook.yml) inside your main Rails app. Then have our engine pull the values out of these files to configure omniauth.</p>

<pre><code>$&gt; cd undevise/config
$&gt; mkdir initializers
$&gt; touch initializers/omniauth.rb

# We have to create the initializers directory because it not created by default.

# undevise/config/initializers/omniauth.rb
providers = %w(twitter facebook).inject([]) do |providers, provider|
  fpath = Rails.root.join('config', "#{provider}.yml")

  if File.exists?(fpath)
    config = YAML.load_file(fpath)
    providers &lt;&lt; [ provider, config['consumer_key'], config['consumer_secret'] ]
  end

  providers
end

raise 'You have not created config/twitter.yml or config/facebook.yml' if providers.empty?

Rails.application.config.middleware.use OmniAuth::Builder do
  providers.each do |p|
    provider *p
  end
end
</code></pre>

<p>Now, let’s go back to our main Rails app and start the server.</p>

<pre><code>$&gt; cd social_app
$&gt; rails s
=&gt; Booting WEBrick
=&gt; Rails 3.2.1 application starting in development on http://0.0.0.0:3000
=&gt; Call with -d to detach
=&gt; Ctrl-C to shutdown server
Exiting
/Users/greg/dev/tmp/ruby/engine-tutorial/undevise/config/initializers/omniauth.rb:12:in `&lt;top (required)&gt;': You have not created config/twitter.yml or config/facebook.yml (RuntimeError)
</code></pre>

<p>Oops! We forgot to create our Twitter or Facebook configuration file. In your main Rails app, go ahead and create config/twitter.yml. If you are not familiar with Twitter apps, visit their developer site at <a href="https://dev.twitter.com/">https://dev.twitter.com/</a></p>

<h3>Gemfile dependencies and sub-depencies</h3>

<pre><code># social_app/config/twitter.yml
consumer_key:  'APP_CONSUMER_KEY'
consumer_secret: 'APP_CONSUMER_SECRET'

$&gt; rails s
=&gt; Booting WEBrick
=&gt; Rails 3.2.1 application starting in development on http://0.0.0.0:3000
=&gt; Call with -d to detach
=&gt; Ctrl-C to shutdown server
Exiting
/Users/greg/dev/tmp/ruby/engine-tutorial/undevise/config/initializers/omniauth.rb:12:in `&lt;top (required)&gt;': uninitialized constant OmniAuth (NameError)
     from /Users/greg/.rbenv/versions/1.9.3-p0/lib/ruby/gems/1.9.1/gems/railties-3.2.1/lib/rails/engine.rb:588:in `block (2 levels) in &lt;class:Engine&gt;'
</code></pre>

<p>The NameError occurs because during the main Rails’ app boot up, Bundler will only require dependencies listed in the Gemfile but not the sub-dependencies. As you can see from Gemfile.lock, omniauth is not a direct dependency. You could list the gems in your main app’s Gemfile but that’s defeating the purpose of isolating the gem dependencies through your engine.</p>

<p>The solution right now is to require your dependencies inside your engine and the place to do that is inside lib/undevise/engine.rb</p>

<pre><code># undevise/lib/undevise/engine.rb
require 'omniauth'
require 'omniauth-twitter'
require 'omniauth-facebook'

module Undevise
  class Engine &lt; ::Rails::Engine
    isolate_namespace Undevise
  end
end
</code></pre>

<p>After listing required dependencies inside your engine, restart your main Rails app, then visit <a href="http://localhost:3000/auth/twitter/">http://localhost:3000/auth/twitter/</a></p>

<p>When you visit <a href="http://localhost:3000/auth/twitter/,">http://localhost:3000/auth/twitter/,</a> you should see the error above. The callback url is part of OmniAuth’s behaviour and should be fixed by adding a route in your engine and adding the method to handle it in your controller.</p>

<pre><code># undevise/config/routes.rb
Undevise::Engine.routes.draw do
  root :to =&gt; 'auth#index'
  match ':provider/callback' =&gt; 'auth#callback'
end

# undevise/app/controllers/undevise/auth_controller.rb
module Undevise
  class AuthController &lt; ApplicationController

    def index
      render :text =&gt; 'Hello world'
    end

    def callback
      render :text =&gt; "Hello from #{params[:provider]}"
    end

  end
end
</code></pre>

<p>If everything work fine, you should see a message from Twitter.</p>

<p>We only scratched the surface with Rails 3 engine. Your engine, much like any normal Rails app, can have models and migrations, javascripts, css, specs, etc. If you want to dig deeper into engines, I recommend Rails 3 in Action by Ryan Bigg and Yehuda Katz. It includes a whole chapter about engines, discussion of middleware, and how tests your engine.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Architecture the Lost Years by Robert Martin]]></title>
    <link href="http://gregmoreno.ca/architecture-the-lost-years-by-robert-martin/"/>
    <updated>2012-03-06T05:14:15-08:00</updated>
    <id>http://gregmoreno.ca/architecture-the-lost-years-by-robert-martin</id>
    <content type="html"><![CDATA[<p><a href="http://www.youtube.com/watch?v=WpkDN78P884" title="Architecture the Lost Years by Robert Martin"><img src="http://img.youtube.com/vi/WpkDN78P884/0.jpg" alt="Architecture the Lost Years by Robert Martin" /></a></p>

<p>http://youtu.be/WpkDN78P884</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[More Ruby tips and tricks]]></title>
    <link href="http://gregmoreno.ca/more-ruby-tips-and-tricks/"/>
    <updated>2012-03-03T01:50:39-08:00</updated>
    <id>http://gregmoreno.ca/more-ruby-tips-and-tricks</id>
    <content type="html"><![CDATA[<h3>String to number conversion gotcha</h3>

<pre><code>&gt;&gt; Float('3.14159')
=&gt; 3.14159 
&gt;&gt; '3.14159'.to_f
=&gt; 3.14159 

# However, Float() method will return an exception if given
# a bad input while to_f() will ignore everything from the 
# offending character.

&gt;&gt; Float('3.x14159')
ArgumentError: invalid value for Float(): "3.x14159"
  from (irb):4:in 'Float'
  from (irb):4

&gt;&gt; '3.x14159'.to_f
=&gt; 3.0


# Similar case with to_i() and Integer().

&gt;&gt; Integer('19x69')
ArgumentError: invalid value for Integer(): "19x69"
  from (irb):15:in 'Integer'
  from (irb):15
  from /Users/greg/.rvm/rubies/ruby-1.9.2-p0/bin/irb:17:in '&lt;main&gt;'

&gt;&gt; '19x69'.to_i
=&gt; 19
</code></pre>

<h3>Case insensitive regular expression</h3>

<pre><code># Regex is case sensitive by default.
# Adding 'i' for insensitive match
puts 'matches' if  /AM/i =~ 'am'
</code></pre>

<h3>Hash is ordered in 1.9</h3>

<pre><code># new syntax in 1.9
h = {first: 'a', second: 'b', third: 'c'}

# hashes in 1.9 are ordered
h.each do |e|
  pp e
end
</code></pre>

<h3>Filter a list using several conditions</h3>

<pre><code>conditions = [
    proc { |i| i &gt; 5 },
    proc { |i| (i % 2).zero? },
    proc { |i| (i % 3).zero? }
  ]

matches = (1..100).select do |i|
  conditions.all? { |c| c[i] }
end
</code></pre>

<h3>Randomly pick an element from an array</h3>

<pre><code>&gt;&gt; [1,2,3,4,5].sample
=&gt; 2 
&gt;&gt; [1,2,3,4,5].sample
=&gt; 1 

# pick 2 random elements
&gt;&gt; [1,2,3,4,5].sample(2)
=&gt; [1, 5]
</code></pre>

<h3>List methods unique to a class</h3>

<pre><code># List all instance methods that starts with `re` including those inherited by String.

&gt;&gt; String.instance_methods.grep /^re/
=&gt; [:replace, :reverse, :reverse!, :respond_to?, :respond_to_missing?] 

# List methods unique to String, i.e. not include
# those defined by its ancestors.

&gt;&gt; String.instance_methods(false).grep /^re/
=&gt; [:replace, :reverse, :reverse!]
</code></pre>

<h3>Globbing key-value pairs</h3>

<pre><code>&gt;&gt; h = Hash['a', 1, 'b', 2]
=&gt; {"a"=&gt;1, "b"=&gt;2}

&gt;&gt; h = Hash[ [ ['a', 1], ['b', 2] ] ] 
=&gt; {"a"=&gt;1, "b"=&gt;2}

&gt;&gt; h = Hash[ 'a' =&gt; 1, 'b' =&gt; 2 ]
=&gt; {"a"=&gt;1, "b"=&gt;2}

# The first form is very useful for globbing key-value pairs in Rails’ routes. For example, if you have the following:

# route definition in Rails 3
match 'items/*specs' =&gt; 'items#specs'

# sample url
http://localhost:3000/items/year/1969/month/7/day/21

# params[:specs] will be set

&gt;&gt; params[:specs]
=&gt; "year/1969/month/7/day/21"

&gt;&gt; h = Hash[*params[:specs].split('/')]
=&gt; {"year"=&gt;"1969", "month"=&gt;"7", "day"=&gt;"21"}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby tips and tricks]]></title>
    <link href="http://gregmoreno.ca/24-ruby-language-tips-and-tricks/"/>
    <updated>2012-02-09T01:35:44-08:00</updated>
    <id>http://gregmoreno.ca/24-ruby-language-tips-and-tricks</id>
    <content type="html"><![CDATA[<h3>Generate random numbers within a given range</h3>

<pre><code>irb(main):019:0&gt; rand(10..20)
=&gt; 12
irb(main):020:0&gt; rand(10...20) # works with exclusive range
=&gt; 16
</code></pre>

<h3>Dump your object using awesome_print</h3>

<pre><code># Install the gem first
gem install awesome_print

irb(main):001:0&gt; require 'ap'
=&gt; true
irb(main):002:0&gt; ap :a =&gt; 1, :b =&gt; 'greg', :c =&gt; [1,2,3]
{
    :a =&gt; 1,
    :b =&gt; "greg",
    :c =&gt; [
        [0] 1,
        [1] 2,
        [2] 3
    ]
}
=&gt; {:a=&gt;1, :b=&gt;"greg", :c=&gt;[1, 2, 3]}
</code></pre>

<h3>Concatenating strings</h3>

<pre><code>irb(main):005:0&gt; "abc" + "def"
=&gt; "abcdef"
irb(main):006:0&gt; "abc".concat("def")
=&gt; "abcdef"
irb(main):007:0&gt; x = "abc" "def"
=&gt; "abcdef"
</code></pre>

<h3>Include modules in a single line</h3>

<pre><code>class MyClass
  include Module1, Module2, Module3
  # However, the modules are included in reverse order. Confusing eh!
end
</code></pre>

<h3>Instance variable interpolation</h3>

<pre><code>irb(main):008:0&gt; @name = "greg"
=&gt; "greg"
irb(main):009:0&gt; "my name is #{@name}"
=&gt; "my name is greg"
irb(main):010:0&gt; "my name is #@name"
=&gt; "my name is greg"
</code></pre>

<p>I still prefer the curly braces.</p>

<h3>Syntax checking</h3>

<pre><code>$ ruby -c facu.rb 
facu.rb:12: syntax error, unexpected keyword_end, expecting $end
</code></pre>

<h3>Zipping arrays</h3>

<pre><code>irb(main):027:0&gt; names = %w(fred jess john)
=&gt; ["fred", "jess", "john"]
irb(main):028:0&gt; ages = [38, 47,91]
=&gt; [38, 47, 91]
irb(main):029:0&gt; locations = %w(spain france usa)
=&gt; ["spain", "france", "usa"]
irb(main):030:0&gt; names.zip(ages)
=&gt; [["fred", 38], ["jess", 47], ["john", 91]]
irb(main):031:0&gt; names.zip(ages, locations)
=&gt; [["fred", 38, "spain"], ["jess", 47, "france"], ["john", 91, "usa"]]
</code></pre>

<h3>Range into arrays</h3>

<pre><code>irb(main):034:0&gt; (10..20).to_a  # what I used to do
=&gt; [10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]
irb(main):035:0&gt; [*10..20]
=&gt; [10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]
</code></pre>

<h3>Using parameter as default value</h3>

<pre><code>irb(main):047:0&gt; def method(a, b=a); "#{a} #{b}"; end
=&gt; nil
irb(main):048:0&gt; method 1
=&gt; "1 1"
irb(main):049:0&gt; method 1, 2
=&gt; "1 2"
</code></pre>

<h3>Put regex match in a variable</h3>

<pre><code>irb(main):058:0&gt; s = "Greg Moreno"
=&gt; "Greg Moreno"
irb(main):059:0&gt; /(?&lt;first&gt;\w+) (?&lt;second&gt;\w+)/ =~ s
=&gt; 0
irb(main):060:0&gt; first
=&gt; "Greg"
irb(main):061:0&gt; second
=&gt; "Moreno"
</code></pre>
]]></content>
  </entry>
  
</feed>
